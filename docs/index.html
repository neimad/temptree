<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>temptree API documentation</title>
<meta name="description" content="Generates temporary files and directories from a tree …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>temptree</code></h1>
</header>
<section id="section-intro">
<p>Generates temporary files and directories from a tree.</p>
<p>The provided <a title="temptree.TemporaryTree" href="#temptree.TemporaryTree"><code>TemporaryTree</code></a> class allows to create complete files hierarchies under a
root <code>tempfile.TemporaryDirectory</code>.</p>
<p>It is well suited for usage within <em>doctests</em> :</p>
<pre><code>&gt;&gt;&gt; from temptree import TemporaryTree
&gt;&gt;&gt; with TemporaryTree({
...     "foo.py": None,
...     "bar": {
...         "bar.py": None,
...         "baz.py": None,
...     }
... }) as root:
...     (root / "foo.py").exists()
...     (root / "bar").is_dir()
...     (root / "bar" / "bar.py").is_file()
...
True
True
True
</code></pre>
<h2 id="installation">Installation</h2>
<p>Add <a title="temptree" href="#temptree"><code>temptree</code></a> to your project dependencies:</p>
<pre><code>poetry add temptree
</code></pre>
<p>If you just need it within your <em>doctests</em>, add it as a development dependency:</p>
<pre><code>poetry add --dev temptree
</code></pre>
<h2 id="documentation">Documentation</h2>
<p><a href="https://neimad.github.io/temptree/">The complete documentation</a> is available from Github Pages.</p>
<h2 id="development">Development</h2>
<p>The development tasks are managed using <a href="https://www.pyinvoke.org/">Invoke</a>. Use it to list the available tasks:</p>
<pre><code>inv -l
</code></pre>
<p>Use the <code>pre-commit</code> task within your repository <code>pre-commit</code> hook:</p>
<pre><code>poetry run invoke pre-commit
</code></pre>
<h2 id="contributing">Contributing</h2>
<p>This project is hosted on <a href="https://github.com/neimad/temptree">Github</a>.</p>
<p>If you're facing an issue using <a title="temptree" href="#temptree"><code>temptree</code></a>, please look at
<a href="https://github.com/neimad/temptree/issues">the existing tickets</a>. Then you may open a new one.</p>
<p>You may also make a <a href="https://github.com/neimad/temptree/pulls">push request</a> to help improve it.</p>
<h2 id="license">License</h2>
<p><a title="temptree" href="#temptree"><code>temptree</code></a> is licensed under the <a href="https://www.gnu.org/licenses/gpl.html">GNU GPL 3</a> or later.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># SPDX-License-Identifier: GPL-3.0-or-later
# Copyright © 2019 Damien Flament
# This file is part of temptree.

&#34;&#34;&#34;Generates temporary files and directories from a tree.

The provided `TemporaryTree` class allows to create complete files hierarchies under a
root `tempfile.TemporaryDirectory`.

It is well suited for usage within *doctests* :

    &gt;&gt;&gt; from temptree import TemporaryTree
    &gt;&gt;&gt; with TemporaryTree({
    ...     &#34;foo.py&#34;: None,
    ...     &#34;bar&#34;: {
    ...         &#34;bar.py&#34;: None,
    ...         &#34;baz.py&#34;: None,
    ...     }
    ... }) as root:
    ...     (root / &#34;foo.py&#34;).exists()
    ...     (root / &#34;bar&#34;).is_dir()
    ...     (root / &#34;bar&#34; / &#34;bar.py&#34;).is_file()
    ...
    True
    True
    True

Installation
------------

Add `temptree` to your project dependencies:

    poetry add temptree

If you just need it within your *doctests*, add it as a development dependency:

    poetry add --dev temptree

Documentation
-------------

[The complete documentation][documentation] is available from Github Pages.

Development
-----------

The development tasks are managed using [Invoke]. Use it to list the available tasks:

    inv -l

Use the `pre-commit` task within your repository `pre-commit` hook:

    poetry run invoke pre-commit

Contributing
------------

This project is hosted on [Github][repository].

If you&#39;re facing an issue using `temptree`, please look at
[the existing tickets][issues]. Then you may open a new one.

You may also make a [push request][pull-requests] to help improve it.

License
-------

`temptree` is licensed under the [GNU GPL 3][GPL] or later.

[documentation]: https://neimad.github.io/temptree/
[Invoke]: https://www.pyinvoke.org/
[repository]: https://github.com/neimad/temptree
[issues]: https://github.com/neimad/temptree/issues
[pull-requests]: https://github.com/neimad/temptree/pulls
[GPL]: https://www.gnu.org/licenses/gpl.html

&#34;&#34;&#34;

from pathlib import Path
from tempfile import TemporaryDirectory


class TemporaryTree(object):
    &#34;&#34;&#34;A tree of files and directories located in a `pathlib.TemporaryDirectory`.

    To build a hierarchy of files and directories, use nested dictionnaries:

    &gt;&gt;&gt; tree = TemporaryTree({
    ...     &#34;foo.py&#34;: None,
    ...     &#34;bar.py&#34;: None,
    ...     &#34;baz&#34;: {
    ...         &#34;foo.cfg&#34;: None,
    ...         &#34;bar.ini&#34;: None
    ...     }
    ... })
    ...

    A temporary directory is created and is available through the `TemporaryTree.root`
    attribute as a `pathlib.Path`:

        &gt;&gt;&gt; from pathlib import Path
        &gt;&gt;&gt; isinstance(tree.root, Path)
        True


    The specified files hierarchy is created under the root:

        &gt;&gt;&gt; for f in sorted(tree.root.rglob(&#34;*&#34;)):
        ...     print(f.relative_to(tree.root))
        ...
        bar.py
        baz
        baz/bar.ini
        baz/foo.cfg
        foo.py

    The tree is cleaned up when the `TemporaryTree` instance is destructed:

        &gt;&gt;&gt; root = tree.root
        &gt;&gt;&gt; del tree
        &gt;&gt;&gt; root.exists()
        False

    It can also be explicitly cleaned up using the `TemporaryTree.cleanup` method.

    Context manager
    ---------------

    A tree can be used as a context manager returning the root `pathlib.Path`:

        &gt;&gt;&gt; with TemporaryTree({&#34;foo.py&#34;: None}) as root:
        ...     foo = root / &#34;foo.py&#34;
        ...     foo.exists()
        ...
        True


    On context completion, the tree is cleaned up.

    Files mode and access flags
    ---------------------------

    The files mode can be specified as a value within the files hierarchy specification
    dictionnary:

        &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: 0o700})
        &gt;&gt;&gt; foo = tree.root / &#34;foo.py&#34;
        &gt;&gt;&gt; format(foo.stat().st_mode, &#34;o&#34;)
        &#39;100700&#39;

    Slash operator
    --------------

    The slash operator can be used in the same way as with `pathlib.Path` objects:

        &gt;&gt;&gt; str(tree / &#34;baz.py&#34;) == f&#34;{str(tree.root)}/baz.py&#34;
        True

    &#34;&#34;&#34;

    def __init__(self, tree):
        self._root = TemporaryDirectory()

        self._build(self.root, tree)

    @property
    def root(self):
        &#34;&#34;&#34;The root of the tree as a `pathlib.Path` object.&#34;&#34;&#34;
        return Path(self._root.name)

    def __enter__(self):
        &#34;&#34;&#34;Gives the root directory.

        Returns
        -------
            The tree root.

        &#34;&#34;&#34;
        return self.root

    def __exit__(self, e_type, e_value, e_traceback):
        &#34;&#34;&#34;Exits the context.&#34;&#34;&#34;
        pass

    def __truediv__(self, other):
        &#34;&#34;&#34;Uses the slash operator to create childs paths from the root.&#34;&#34;&#34;
        return self.root.__truediv__(other)

    def _build(self, directory, tree):
        &#34;&#34;&#34;Creates the files and directories specified by the `tree` dictionnary.

        Parameters
        ----------
        directory: Path
            The directory to build the files hierarchy in.
        tree: dict
            The files hierarchy specification.

        &#34;&#34;&#34;
        for name, value in tree.items():
            if isinstance(value, dict):
                subdirectory = directory / name
                subdirectory.mkdir()

                assert subdirectory.exists()

                self._build(subdirectory, value)
            else:
                file = directory / name
                if value:
                    file.touch(mode=value)
                else:
                    file.touch()

                assert file.exists()

    def cleanup(self):
        &#34;&#34;&#34;Cleans up the tree.

        The root temporary directory is cleaned up:

            &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: None})
            &gt;&gt;&gt; tree.root.exists()
            True
            &gt;&gt;&gt; tree.cleanup()
            &gt;&gt;&gt; tree.root.exists()
            False

        &#34;&#34;&#34;
        self._root.cleanup()

    def __repr__(self):
        &#34;&#34;&#34;Represents the tree by the location of its root.

        The `TemporaryTree` is represented by the location of its root in the
        filesystem :

            &gt;&gt;&gt; tree = TemporaryTree({})
            &gt;&gt;&gt; repr(tree) == f&#34;&lt;TemporaryTree at {tree.root}&gt;&#34;
            True

        &#34;&#34;&#34;
        class_name = self.__class__.__name__

        return f&#34;&lt;{class_name} at {str(self.root)}&gt;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="temptree.TemporaryTree"><code class="flex name class">
<span>class <span class="ident">TemporaryTree</span></span>
<span>(</span><span>tree)</span>
</code></dt>
<dd>
<section class="desc"><p>A tree of files and directories located in a <code>pathlib.TemporaryDirectory</code>.</p>
<p>To build a hierarchy of files and directories, use nested dictionnaries:</p>
<pre><code>&gt;&gt;&gt; tree = TemporaryTree({
...     "foo.py": None,
...     "bar.py": None,
...     "baz": {
...         "foo.cfg": None,
...         "bar.ini": None
...     }
... })
...
</code></pre>
<p>A temporary directory is created and is available through the <a title="temptree.TemporaryTree.root" href="#temptree.TemporaryTree.root"><code>TemporaryTree.root</code></a>
attribute as a <code>pathlib.Path</code>:</p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; isinstance(tree.root, Path)
True
</code></pre>
<p>The specified files hierarchy is created under the root:</p>
<pre><code>&gt;&gt;&gt; for f in sorted(tree.root.rglob("*")):
...     print(f.relative_to(tree.root))
...
bar.py
baz
baz/bar.ini
baz/foo.cfg
foo.py
</code></pre>
<p>The tree is cleaned up when the <a title="temptree.TemporaryTree" href="#temptree.TemporaryTree"><code>TemporaryTree</code></a> instance is destructed:</p>
<pre><code>&gt;&gt;&gt; root = tree.root
&gt;&gt;&gt; del tree
&gt;&gt;&gt; root.exists()
False
</code></pre>
<p>It can also be explicitly cleaned up using the <a title="temptree.TemporaryTree.cleanup" href="#temptree.TemporaryTree.cleanup"><code>TemporaryTree.cleanup()</code></a> method.</p>
<h2 id="context-manager">Context manager</h2>
<p>A tree can be used as a context manager returning the root <code>pathlib.Path</code>:</p>
<pre><code>&gt;&gt;&gt; with TemporaryTree({"foo.py": None}) as root:
...     foo = root / "foo.py"
...     foo.exists()
...
True
</code></pre>
<p>On context completion, the tree is cleaned up.</p>
<h2 id="files-mode-and-access-flags">Files mode and access flags</h2>
<p>The files mode can be specified as a value within the files hierarchy specification
dictionnary:</p>
<pre><code>&gt;&gt;&gt; tree = TemporaryTree({"foo.py": 0o700})
&gt;&gt;&gt; foo = tree.root / "foo.py"
&gt;&gt;&gt; format(foo.stat().st_mode, "o")
'100700'
</code></pre>
<h2 id="slash-operator">Slash operator</h2>
<p>The slash operator can be used in the same way as with <code>pathlib.Path</code> objects:</p>
<pre><code>&gt;&gt;&gt; str(tree / "baz.py") == f"{str(tree.root)}/baz.py"
True
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TemporaryTree(object):
    &#34;&#34;&#34;A tree of files and directories located in a `pathlib.TemporaryDirectory`.

    To build a hierarchy of files and directories, use nested dictionnaries:

    &gt;&gt;&gt; tree = TemporaryTree({
    ...     &#34;foo.py&#34;: None,
    ...     &#34;bar.py&#34;: None,
    ...     &#34;baz&#34;: {
    ...         &#34;foo.cfg&#34;: None,
    ...         &#34;bar.ini&#34;: None
    ...     }
    ... })
    ...

    A temporary directory is created and is available through the `TemporaryTree.root`
    attribute as a `pathlib.Path`:

        &gt;&gt;&gt; from pathlib import Path
        &gt;&gt;&gt; isinstance(tree.root, Path)
        True


    The specified files hierarchy is created under the root:

        &gt;&gt;&gt; for f in sorted(tree.root.rglob(&#34;*&#34;)):
        ...     print(f.relative_to(tree.root))
        ...
        bar.py
        baz
        baz/bar.ini
        baz/foo.cfg
        foo.py

    The tree is cleaned up when the `TemporaryTree` instance is destructed:

        &gt;&gt;&gt; root = tree.root
        &gt;&gt;&gt; del tree
        &gt;&gt;&gt; root.exists()
        False

    It can also be explicitly cleaned up using the `TemporaryTree.cleanup` method.

    Context manager
    ---------------

    A tree can be used as a context manager returning the root `pathlib.Path`:

        &gt;&gt;&gt; with TemporaryTree({&#34;foo.py&#34;: None}) as root:
        ...     foo = root / &#34;foo.py&#34;
        ...     foo.exists()
        ...
        True


    On context completion, the tree is cleaned up.

    Files mode and access flags
    ---------------------------

    The files mode can be specified as a value within the files hierarchy specification
    dictionnary:

        &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: 0o700})
        &gt;&gt;&gt; foo = tree.root / &#34;foo.py&#34;
        &gt;&gt;&gt; format(foo.stat().st_mode, &#34;o&#34;)
        &#39;100700&#39;

    Slash operator
    --------------

    The slash operator can be used in the same way as with `pathlib.Path` objects:

        &gt;&gt;&gt; str(tree / &#34;baz.py&#34;) == f&#34;{str(tree.root)}/baz.py&#34;
        True

    &#34;&#34;&#34;

    def __init__(self, tree):
        self._root = TemporaryDirectory()

        self._build(self.root, tree)

    @property
    def root(self):
        &#34;&#34;&#34;The root of the tree as a `pathlib.Path` object.&#34;&#34;&#34;
        return Path(self._root.name)

    def __enter__(self):
        &#34;&#34;&#34;Gives the root directory.

        Returns
        -------
            The tree root.

        &#34;&#34;&#34;
        return self.root

    def __exit__(self, e_type, e_value, e_traceback):
        &#34;&#34;&#34;Exits the context.&#34;&#34;&#34;
        pass

    def __truediv__(self, other):
        &#34;&#34;&#34;Uses the slash operator to create childs paths from the root.&#34;&#34;&#34;
        return self.root.__truediv__(other)

    def _build(self, directory, tree):
        &#34;&#34;&#34;Creates the files and directories specified by the `tree` dictionnary.

        Parameters
        ----------
        directory: Path
            The directory to build the files hierarchy in.
        tree: dict
            The files hierarchy specification.

        &#34;&#34;&#34;
        for name, value in tree.items():
            if isinstance(value, dict):
                subdirectory = directory / name
                subdirectory.mkdir()

                assert subdirectory.exists()

                self._build(subdirectory, value)
            else:
                file = directory / name
                if value:
                    file.touch(mode=value)
                else:
                    file.touch()

                assert file.exists()

    def cleanup(self):
        &#34;&#34;&#34;Cleans up the tree.

        The root temporary directory is cleaned up:

            &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: None})
            &gt;&gt;&gt; tree.root.exists()
            True
            &gt;&gt;&gt; tree.cleanup()
            &gt;&gt;&gt; tree.root.exists()
            False

        &#34;&#34;&#34;
        self._root.cleanup()

    def __repr__(self):
        &#34;&#34;&#34;Represents the tree by the location of its root.

        The `TemporaryTree` is represented by the location of its root in the
        filesystem :

            &gt;&gt;&gt; tree = TemporaryTree({})
            &gt;&gt;&gt; repr(tree) == f&#34;&lt;TemporaryTree at {tree.root}&gt;&#34;
            True

        &#34;&#34;&#34;
        class_name = self.__class__.__name__

        return f&#34;&lt;{class_name} at {str(self.root)}&gt;&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="temptree.TemporaryTree.root"><code class="name">var <span class="ident">root</span></code></dt>
<dd>
<section class="desc"><p>The root of the tree as a <code>pathlib.Path</code> object.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def root(self):
    &#34;&#34;&#34;The root of the tree as a `pathlib.Path` object.&#34;&#34;&#34;
    return Path(self._root.name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="temptree.TemporaryTree.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Cleans up the tree.</p>
<p>The root temporary directory is cleaned up:</p>
<pre><code>&gt;&gt;&gt; tree = TemporaryTree({"foo.py": None})
&gt;&gt;&gt; tree.root.exists()
True
&gt;&gt;&gt; tree.cleanup()
&gt;&gt;&gt; tree.root.exists()
False
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cleanup(self):
    &#34;&#34;&#34;Cleans up the tree.

    The root temporary directory is cleaned up:

        &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: None})
        &gt;&gt;&gt; tree.root.exists()
        True
        &gt;&gt;&gt; tree.cleanup()
        &gt;&gt;&gt; tree.root.exists()
        False

    &#34;&#34;&#34;
    self._root.cleanup()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#development">Development</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#license">License</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="temptree.TemporaryTree" href="#temptree.TemporaryTree">TemporaryTree</a></code></h4>
<ul class="">
<li><code><a title="temptree.TemporaryTree.cleanup" href="#temptree.TemporaryTree.cleanup">cleanup</a></code></li>
<li><code><a title="temptree.TemporaryTree.root" href="#temptree.TemporaryTree.root">root</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>