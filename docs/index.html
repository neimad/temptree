<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.4" />
<title>temptree API documentation</title>
<meta name="description" content="Generates temporary files and directories from a tree …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>temptree</code></h1>
</header>
<section id="section-intro">
<p>Generates temporary files and directories from a tree.</p>
<p><a href="https://travis-ci.org/neimad/temptree"><img alt="Build Status" src="https://img.shields.io/travis/neimad/temptree?style=flat-square"></a>
<a href="https://pypi.org/project/temptree/"><img alt="PyPI" src="https://img.shields.io/pypi/v/temptree?style=flat-square"></a>
<a href="https://pypi.org/project/temptree/"><img alt="Python Version" src="https://img.shields.io/pypi/pyversions/temptree?style=flat-square"></a>
<a href="https://github.com/neimad/temptree/blob/master/LICENSE.md"><img alt="License" src="https://img.shields.io/github/license/neimad/temptree?style=flat-square"></a></p>
<p>The provided <a title="temptree.TemporaryTree" href="#temptree.TemporaryTree"><code>TemporaryTree</code></a> class allows to create complete files hierarchies
under a root <code>tempfile.TemporaryDirectory</code>.</p>
<p>It is well suited for usage within <em>doctests</em> :</p>
<pre><code>&gt;&gt;&gt; from temptree import TemporaryTree

&gt;&gt;&gt; with TemporaryTree(["foo.py", "bar.py"]) as root:
...     (root / "foo.py").is_file()
...     (root / "bar.py").is_file()
...
True
True
</code></pre>
<p>A complete file hierarchy can be easily created, including text files content
and files mode:</p>
<pre><code>&gt;&gt;&gt; with TemporaryTree({
...     "foo.py": ('''
...     import os
...     import sys
...
...     FOO = "foo"
...     ''', 0o700),
...     "bar": {
...         "bar.py": '''
...         import foo
...         import pathlib
...
...         def bar():
...             return foo.FOO
...         ''',
...         "baz.py": None,
...     }
... }) as root:
...     (root / "foo.py").exists()
...     (root / "bar").is_dir()
...     (root / "bar" / "bar.py").is_file()
...     (root / "bar" / "baz.py").is_file()
...
True
True
True
True
</code></pre>
<h2 id="installation">Installation</h2>
<p>Add <a title="temptree" href="#temptree"><code>temptree</code></a> to your project dependencies:</p>
<pre><code>poetry add temptree
</code></pre>
<p>If you just need it within your <em>doctests</em>, add it as a development dependency:</p>
<pre><code>poetry add --dev temptree
</code></pre>
<h2 id="documentation">Documentation</h2>
<p><a href="https://neimad.github.io/temptree/">The complete documentation</a> is available from Github Pages.</p>
<h2 id="development">Development</h2>
<p>The development tasks are managed using <a href="https://pyinvoke.org">Invoke</a>. Use it to list the available
tasks:</p>
<pre><code>poetry run invoke --list
</code></pre>
<p>Install the <a href="https://pre-commit.com">pre-commit</a> hook within your repository:</p>
<pre><code>poetry run pre-commit install
</code></pre>
<p>Run the tests using <a href="https://pytest.org">Pytest</a>:</p>
<pre><code>poetry run pytest
</code></pre>
<h2 id="contributing">Contributing</h2>
<p>This project is hosted on a <a href="https://github.com/neimad/temptree">Github repository</a>.</p>
<p>If you're facing an issue using <a title="temptree" href="#temptree"><code>temptree</code></a>, please look at
<a href="https://github.com/neimad/temptree/issues">the existing tickets</a>. Then you may open a new one.</p>
<p>You may also <a href="https://github.com/neimad/temptree/pulls">make a push request</a> to help improve it.</p>
<h2 id="changelog">Changelog</h2>
<p>See <a href="https://github.com/neimad/temptree/blob/master/CHANGELOG.md">the changelog</a> to see what changes have been made and what you can expect
in the next release.</p>
<h2 id="license">License</h2>
<p><a title="temptree" href="#temptree"><code>temptree</code></a> is licensed under the <a href="https://github.com/neimad/temptree/blob/master/LICENSE.md">GNU GPL 3 or later</a>.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># SPDX-License-Identifier: GPL-3.0-or-later
# Copyright © 2019 Damien Flament
# This file is part of temptree.

&#34;&#34;&#34;Generates temporary files and directories from a tree.

[![Build Status][ci-badge]][ci]
[![PyPI][pypi-badge]][package]
[![Python Version][py-versions-badge]][package]
[![License][license-badge]][GNU GPL 3 or later]

The provided `TemporaryTree` class allows to create complete files hierarchies
under a root `tempfile.TemporaryDirectory`.

It is well suited for usage within *doctests* :

    &gt;&gt;&gt; from temptree import TemporaryTree

    &gt;&gt;&gt; with TemporaryTree([&#34;foo.py&#34;, &#34;bar.py&#34;]) as root:
    ...     (root / &#34;foo.py&#34;).is_file()
    ...     (root / &#34;bar.py&#34;).is_file()
    ...
    True
    True

A complete file hierarchy can be easily created, including text files content
and files mode:

    &gt;&gt;&gt; with TemporaryTree({
    ...     &#34;foo.py&#34;: (&#39;&#39;&#39;
    ...     import os
    ...     import sys
    ...
    ...     FOO = &#34;foo&#34;
    ...     &#39;&#39;&#39;, 0o700),
    ...     &#34;bar&#34;: {
    ...         &#34;bar.py&#34;: &#39;&#39;&#39;
    ...         import foo
    ...         import pathlib
    ...
    ...         def bar():
    ...             return foo.FOO
    ...         &#39;&#39;&#39;,
    ...         &#34;baz.py&#34;: None,
    ...     }
    ... }) as root:
    ...     (root / &#34;foo.py&#34;).exists()
    ...     (root / &#34;bar&#34;).is_dir()
    ...     (root / &#34;bar&#34; / &#34;bar.py&#34;).is_file()
    ...     (root / &#34;bar&#34; / &#34;baz.py&#34;).is_file()
    ...
    True
    True
    True
    True

Installation
------------

Add `temptree` to your project dependencies:

    poetry add temptree

If you just need it within your *doctests*, add it as a development dependency:

    poetry add --dev temptree

Documentation
-------------

[The complete documentation] is available from Github Pages.

Development
-----------

The development tasks are managed using [Invoke]. Use it to list the available
tasks:

    poetry run invoke --list

Install the [pre-commit] hook within your repository:

    poetry run pre-commit install

Run the tests using [Pytest]:

    poetry run pytest

Contributing
------------

This project is hosted on a [Github repository].

If you&#39;re facing an issue using `temptree`, please look at
[the existing tickets]. Then you may open a new one.

You may also [make a push request] to help improve it.

Changelog
---------

See [the changelog] to see what changes have been made and what you can expect
in the next release.

License
-------

`temptree` is licensed under the [GNU GPL 3 or later].

[ci-badge]: https://img.shields.io/travis/neimad/temptree?style=flat-square
[pypi-badge]: https://img.shields.io/pypi/v/temptree?style=flat-square
[py-versions-badge]: https://img.shields.io/pypi/pyversions/temptree?style=flat-square
[license-badge]: https://img.shields.io/github/license/neimad/temptree?style=flat-square

[GNU GPL 3 or later]: https://github.com/neimad/temptree/blob/master/LICENSE.md
[the changelog]: https://github.com/neimad/temptree/blob/master/CHANGELOG.md
[The complete documentation]: https://neimad.github.io/temptree/
[Github repository]: https://github.com/neimad/temptree
[the existing tickets]: https://github.com/neimad/temptree/issues
[make a push request]: https://github.com/neimad/temptree/pulls
[package]: https://pypi.org/project/temptree/
[ci]: https://travis-ci.org/neimad/temptree

[Invoke]: https://pyinvoke.org
[pre-commit]: https://pre-commit.com
[Pytest]: https://pytest.org

&#34;&#34;&#34;

import os
from pathlib import Path
from tempfile import TemporaryDirectory


class TemporaryTree(object):
    &#34;&#34;&#34;A tree of files and directories located in a `pathlib.TemporaryDirectory`.

    To build a list of files, just specify their names in a list:

    &gt;&gt;&gt; with TemporaryTree([&#34;foo.py&#34;, &#34;bar.py&#34;]) as root:
    ...     (root / &#34;foo.py&#34;).is_file()
    ...     (root / &#34;bar.py&#34;).is_file()
    ...
    True
    True

    To build a hierarchy of files and directories, use nested dictionnaries:

    &gt;&gt;&gt; tree = TemporaryTree({
    ...     &#34;foo.py&#34;: None,
    ...     &#34;bar.py&#34;: None,
    ...     &#34;baz&#34;: {
    ...         &#34;foo.cfg&#34;: None,
    ...         &#34;bar.ini&#34;: None
    ...     }
    ... })
    ...

    A temporary directory is created and is available through the `TemporaryTree.root`
    attribute as a `pathlib.Path`:

        &gt;&gt;&gt; from pathlib import Path
        &gt;&gt;&gt; isinstance(tree.root, Path)
        True


    The specified files hierarchy is created under the root:

        &gt;&gt;&gt; for f in sorted(tree.root.rglob(&#34;*&#34;)):
        ...     print(f.relative_to(tree.root))
        ...
        bar.py
        baz
        baz/bar.ini
        baz/foo.cfg
        foo.py

    The tree is cleaned up when the `TemporaryTree` instance is destructed:

        &gt;&gt;&gt; root = tree.root
        &gt;&gt;&gt; del tree
        &gt;&gt;&gt; root.exists()
        False

    It can also be explicitly cleaned up using the `TemporaryTree.cleanup` method.

    Context manager
    ---------------

    A tree can be used as a context manager returning the root `pathlib.Path`:

        &gt;&gt;&gt; with TemporaryTree({&#34;foo.py&#34;: None}) as root:
        ...     foo = root / &#34;foo.py&#34;
        ...     foo.exists()
        ...
        True


    On context completion, the tree is cleaned up.

    Files content
    -------------
    The files text content can be given as a value within the files hierarchy
    specification dictionnary:

        &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: &#39;&#39;&#39;
        ... FOO = &#34;foo&#34;
        ... &#39;&#39;&#39;})
        ...
        &gt;&gt;&gt; foo = tree / &#34;foo.py&#34;
        &gt;&gt;&gt; print(foo.read_text())
        &lt;BLANKLINE&gt;
        FOO = &#34;foo&#34;
        &lt;BLANKLINE&gt;

    Files mode and access flags
    ---------------------------

    The files mode can be specified as a value within the files hierarchy specification
    dictionnary:

        &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: 0o700})
        &gt;&gt;&gt; foo = tree / &#34;foo.py&#34;
        &gt;&gt;&gt; format(foo.stat().st_mode, &#34;o&#34;)
        &#39;100700&#39;

    Slash operator
    --------------

    The slash operator can be used in the same way as with `pathlib.Path` objects:

        &gt;&gt;&gt; str(tree / &#34;baz.py&#34;) == f&#34;{str(tree.root)}/baz.py&#34;
        True

    &#34;&#34;&#34;

    def __init__(self, tree):
        self._root = TemporaryDirectory()

        _build_tree(self.root, tree)

    @property
    def root(self):
        &#34;&#34;&#34;The root of the tree as a `pathlib.Path` object.&#34;&#34;&#34;
        return Path(self._root.name)

    def __enter__(self):
        &#34;&#34;&#34;Gives the root directory.

        Returns
        -------
            The tree root.

        &#34;&#34;&#34;
        return self.root

    def __exit__(self, e_type, e_value, e_traceback):
        &#34;&#34;&#34;Exits the context.&#34;&#34;&#34;
        pass

    def __truediv__(self, other):
        &#34;&#34;&#34;Uses the slash operator to create childs paths from the root.&#34;&#34;&#34;
        return self.root.__truediv__(other)

    def cleanup(self):
        &#34;&#34;&#34;Cleans up the tree.

        The root temporary directory is cleaned up:

            &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: None})
            &gt;&gt;&gt; tree.root.exists()
            True
            &gt;&gt;&gt; tree.cleanup()
            &gt;&gt;&gt; tree.root.exists()
            False

        &#34;&#34;&#34;
        self._root.cleanup()

    def __repr__(self):
        &#34;&#34;&#34;Represents the tree by the location of its root.

        The `TemporaryTree` is represented by the location of its root in the
        filesystem :

            &gt;&gt;&gt; tree = TemporaryTree({})
            &gt;&gt;&gt; repr(tree) == f&#34;&lt;TemporaryTree at {tree.root}&gt;&#34;
            True

        &#34;&#34;&#34;
        class_name = self.__class__.__name__

        return f&#34;&lt;{class_name} at {str(self.root)}&gt;&#34;


class FilenameError(ValueError):
    &#34;&#34;&#34;Inappropriate file name.&#34;&#34;&#34;


def _check_filename(filename):
    r&#34;&#34;&#34;Checks if a filename is appropriate.

    Empty filenames are forbiden:

        &gt;&gt;&gt; _check_filename(&#34;&#34;)
        Traceback (most recent call last):
        ...
        temptree.FilenameError: Can not create a file with an empty name

    Current directory as filename is forbiden:

        &gt;&gt;&gt; from os import curdir

        &gt;&gt;&gt; _check_filename(curdir)
        Traceback (most recent call last):
        ...
        temptree.FilenameError: Can not create a file whose name is `...`

    Parent directory as filename is forbiden:

        &gt;&gt;&gt; from os import pardir

        &gt;&gt;&gt; _check_filename(pardir)
        Traceback (most recent call last):
        ...
        temptree.FilenameError: Can not create a file whose name is `...`

    Filenames containing path components separator are forbiden:

        &gt;&gt;&gt; from os import sep, altsep

        &gt;&gt;&gt; _check_filename(sep)
        Traceback (most recent call last):
        ...
        temptree.FilenameError: Can not create a file whose name contains `...`

        &gt;&gt;&gt; _check_filename(altsep) # doctest: +SKIP
        Traceback (most recent call last):
        ...
        temptree.FilenameError: Can not create a file whose name contains `...`

    Filenames containing a null byte are forbiden:

        &gt;&gt;&gt; _check_filename(&#34;\0&#34;)
        Traceback (most recent call last):
        ...
        temptree.FilenameError: Can not create a file whose name contains a null byte

    &#34;&#34;&#34;
    NULL_BYTE = &#34;\0&#34;

    if len(filename) == 0:
        raise FilenameError(&#34;Can not create a file with an empty name&#34;)

    if filename in (os.curdir, os.pardir):
        raise FilenameError(f&#34;Can not create a file whose name is `{filename}`&#34;)

    if os.sep in filename:
        raise FilenameError(f&#34;Can not create a file whose name contains `{os.sep}`&#34;)

    if os.altsep and os.altsep in filename:
        raise FilenameError(f&#34;Can not create a file whose name contains `{os.altsep}`&#34;)

    if NULL_BYTE in filename:
        raise FilenameError(f&#34;Can not create a file whose name contains a null byte&#34;)


def _build_tree(directory, tree):
    &#34;&#34;&#34;Creates the files hierarchy specified by the tree.

    Files and directories specified by the `tree` dictionnary are created within the
    given directory.

    If the tree is a list, its element are taken as the keys in the tree dictionnary.

    If a value is a list or a dictionnary, it is taken as a subtree under a subdirectory
    whose the name is the related key.

    &#34;&#34;&#34;
    if isinstance(tree, list):
        tree = {name: None for name in tree}

    for name, value in tree.items():
        _check_filename(name)

        if isinstance(value, (list, dict)):
            subdirectory = directory / name
            subdirectory.mkdir()

            assert subdirectory.exists()

            _build_tree(subdirectory, value)
        else:
            file = directory / name

            if value is None:
                value = (None, None)
            elif isinstance(value, (int, str)):
                value = (value, None)

            _create_file(file, value)

            assert file.exists()


def _create_file(file, specification):
    &#34;&#34;&#34;Creates the file following the given specification.

    The `file` is created while following the `specification`.

        &gt;&gt;&gt; from tempfile import TemporaryDirectory
        &gt;&gt;&gt; from pathlib import Path

        &gt;&gt;&gt; tempdir = TemporaryDirectory()
        &gt;&gt;&gt; dir = Path(tempdir.name)
        &gt;&gt;&gt; file = dir / &#34;file&#34;

        &gt;&gt;&gt; file.exists()
        False
        &gt;&gt;&gt; _create_file(file, (0o711, &#34;file content&#34;))
        &gt;&gt;&gt; file.is_file()
        True
        &gt;&gt;&gt; file.read_text()
        &#39;file content&#39;
        &gt;&gt;&gt; format(file.stat().st_mode, &#34;o&#34;)
        &#39;100711&#39;

    The specification must be an iterable containing:

     - the file mode as an integer,
     - the file content as a string.

    If the file mode is not specified, the default from `pathlib.Path.touch` is used:

        &gt;&gt;&gt; file.unlink()
        &gt;&gt;&gt; from os import umask

        &gt;&gt;&gt; _create_file(file, (None, &#34;file content&#34;))
        &gt;&gt;&gt; file.read_text()
        &#39;file content&#39;
        &gt;&gt;&gt; file.stat().st_mode == 0o100666 - umask(0)
        True

    If the file content is not specified, it is left empty:

        &gt;&gt;&gt; file.unlink()

        &gt;&gt;&gt; _create_file(file, (0o711, None))
        &gt;&gt;&gt; file.read_text()
        &#39;&#39;
        &gt;&gt;&gt; format(file.stat().st_mode, &#34;o&#34;)
        &#39;100711&#39;

    &#34;&#34;&#34;
    content = None
    mode = None

    for value in specification:
        if isinstance(value, str):
            content = value
        elif isinstance(value, int):
            mode = value

    file.touch()

    if content:
        file.write_text(content)

    if mode:
        file.chmod(mode)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="temptree.FilenameError"><code class="flex name class">
<span>class <span class="ident">FilenameError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Inappropriate file name.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class FilenameError(ValueError):
    &#34;&#34;&#34;Inappropriate file name.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="temptree.TemporaryTree"><code class="flex name class">
<span>class <span class="ident">TemporaryTree</span></span>
<span>(</span><span>tree)</span>
</code></dt>
<dd>
<section class="desc"><p>A tree of files and directories located in a <code>pathlib.TemporaryDirectory</code>.</p>
<p>To build a list of files, just specify their names in a list:</p>
<pre><code>&gt;&gt;&gt; with TemporaryTree(["foo.py", "bar.py"]) as root:
...     (root / "foo.py").is_file()
...     (root / "bar.py").is_file()
...
True
</code></pre>
<p>True</p>
<p>To build a hierarchy of files and directories, use nested dictionnaries:</p>
<pre><code>&gt;&gt;&gt; tree = TemporaryTree({
...     "foo.py": None,
...     "bar.py": None,
...     "baz": {
...         "foo.cfg": None,
...         "bar.ini": None
...     }
... })
...
</code></pre>
<p>A temporary directory is created and is available through the <a title="temptree.TemporaryTree.root" href="#temptree.TemporaryTree.root"><code>TemporaryTree.root</code></a>
attribute as a <code>pathlib.Path</code>:</p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; isinstance(tree.root, Path)
True
</code></pre>
<p>The specified files hierarchy is created under the root:</p>
<pre><code>&gt;&gt;&gt; for f in sorted(tree.root.rglob("*")):
...     print(f.relative_to(tree.root))
...
bar.py
baz
baz/bar.ini
baz/foo.cfg
foo.py
</code></pre>
<p>The tree is cleaned up when the <a title="temptree.TemporaryTree" href="#temptree.TemporaryTree"><code>TemporaryTree</code></a> instance is destructed:</p>
<pre><code>&gt;&gt;&gt; root = tree.root
&gt;&gt;&gt; del tree
&gt;&gt;&gt; root.exists()
False
</code></pre>
<p>It can also be explicitly cleaned up using the <a title="temptree.TemporaryTree.cleanup" href="#temptree.TemporaryTree.cleanup"><code>TemporaryTree.cleanup()</code></a> method.</p>
<h2 id="context-manager">Context manager</h2>
<p>A tree can be used as a context manager returning the root <code>pathlib.Path</code>:</p>
<pre><code>&gt;&gt;&gt; with TemporaryTree({"foo.py": None}) as root:
...     foo = root / "foo.py"
...     foo.exists()
...
True
</code></pre>
<p>On context completion, the tree is cleaned up.</p>
<h2 id="files-content">Files content</h2>
<p>The files text content can be given as a value within the files hierarchy
specification dictionnary:</p>
<pre><code>&gt;&gt;&gt; tree = TemporaryTree({"foo.py": '''
... FOO = "foo"
... '''})
...
&gt;&gt;&gt; foo = tree / "foo.py"
&gt;&gt;&gt; print(foo.read_text())
&lt;BLANKLINE&gt;
FOO = "foo"
&lt;BLANKLINE&gt;
</code></pre>
<h2 id="files-mode-and-access-flags">Files mode and access flags</h2>
<p>The files mode can be specified as a value within the files hierarchy specification
dictionnary:</p>
<pre><code>&gt;&gt;&gt; tree = TemporaryTree({"foo.py": 0o700})
&gt;&gt;&gt; foo = tree / "foo.py"
&gt;&gt;&gt; format(foo.stat().st_mode, "o")
'100700'
</code></pre>
<h2 id="slash-operator">Slash operator</h2>
<p>The slash operator can be used in the same way as with <code>pathlib.Path</code> objects:</p>
<pre><code>&gt;&gt;&gt; str(tree / "baz.py") == f"{str(tree.root)}/baz.py"
True
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TemporaryTree(object):
    &#34;&#34;&#34;A tree of files and directories located in a `pathlib.TemporaryDirectory`.

    To build a list of files, just specify their names in a list:

    &gt;&gt;&gt; with TemporaryTree([&#34;foo.py&#34;, &#34;bar.py&#34;]) as root:
    ...     (root / &#34;foo.py&#34;).is_file()
    ...     (root / &#34;bar.py&#34;).is_file()
    ...
    True
    True

    To build a hierarchy of files and directories, use nested dictionnaries:

    &gt;&gt;&gt; tree = TemporaryTree({
    ...     &#34;foo.py&#34;: None,
    ...     &#34;bar.py&#34;: None,
    ...     &#34;baz&#34;: {
    ...         &#34;foo.cfg&#34;: None,
    ...         &#34;bar.ini&#34;: None
    ...     }
    ... })
    ...

    A temporary directory is created and is available through the `TemporaryTree.root`
    attribute as a `pathlib.Path`:

        &gt;&gt;&gt; from pathlib import Path
        &gt;&gt;&gt; isinstance(tree.root, Path)
        True


    The specified files hierarchy is created under the root:

        &gt;&gt;&gt; for f in sorted(tree.root.rglob(&#34;*&#34;)):
        ...     print(f.relative_to(tree.root))
        ...
        bar.py
        baz
        baz/bar.ini
        baz/foo.cfg
        foo.py

    The tree is cleaned up when the `TemporaryTree` instance is destructed:

        &gt;&gt;&gt; root = tree.root
        &gt;&gt;&gt; del tree
        &gt;&gt;&gt; root.exists()
        False

    It can also be explicitly cleaned up using the `TemporaryTree.cleanup` method.

    Context manager
    ---------------

    A tree can be used as a context manager returning the root `pathlib.Path`:

        &gt;&gt;&gt; with TemporaryTree({&#34;foo.py&#34;: None}) as root:
        ...     foo = root / &#34;foo.py&#34;
        ...     foo.exists()
        ...
        True


    On context completion, the tree is cleaned up.

    Files content
    -------------
    The files text content can be given as a value within the files hierarchy
    specification dictionnary:

        &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: &#39;&#39;&#39;
        ... FOO = &#34;foo&#34;
        ... &#39;&#39;&#39;})
        ...
        &gt;&gt;&gt; foo = tree / &#34;foo.py&#34;
        &gt;&gt;&gt; print(foo.read_text())
        &lt;BLANKLINE&gt;
        FOO = &#34;foo&#34;
        &lt;BLANKLINE&gt;

    Files mode and access flags
    ---------------------------

    The files mode can be specified as a value within the files hierarchy specification
    dictionnary:

        &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: 0o700})
        &gt;&gt;&gt; foo = tree / &#34;foo.py&#34;
        &gt;&gt;&gt; format(foo.stat().st_mode, &#34;o&#34;)
        &#39;100700&#39;

    Slash operator
    --------------

    The slash operator can be used in the same way as with `pathlib.Path` objects:

        &gt;&gt;&gt; str(tree / &#34;baz.py&#34;) == f&#34;{str(tree.root)}/baz.py&#34;
        True

    &#34;&#34;&#34;

    def __init__(self, tree):
        self._root = TemporaryDirectory()

        _build_tree(self.root, tree)

    @property
    def root(self):
        &#34;&#34;&#34;The root of the tree as a `pathlib.Path` object.&#34;&#34;&#34;
        return Path(self._root.name)

    def __enter__(self):
        &#34;&#34;&#34;Gives the root directory.

        Returns
        -------
            The tree root.

        &#34;&#34;&#34;
        return self.root

    def __exit__(self, e_type, e_value, e_traceback):
        &#34;&#34;&#34;Exits the context.&#34;&#34;&#34;
        pass

    def __truediv__(self, other):
        &#34;&#34;&#34;Uses the slash operator to create childs paths from the root.&#34;&#34;&#34;
        return self.root.__truediv__(other)

    def cleanup(self):
        &#34;&#34;&#34;Cleans up the tree.

        The root temporary directory is cleaned up:

            &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: None})
            &gt;&gt;&gt; tree.root.exists()
            True
            &gt;&gt;&gt; tree.cleanup()
            &gt;&gt;&gt; tree.root.exists()
            False

        &#34;&#34;&#34;
        self._root.cleanup()

    def __repr__(self):
        &#34;&#34;&#34;Represents the tree by the location of its root.

        The `TemporaryTree` is represented by the location of its root in the
        filesystem :

            &gt;&gt;&gt; tree = TemporaryTree({})
            &gt;&gt;&gt; repr(tree) == f&#34;&lt;TemporaryTree at {tree.root}&gt;&#34;
            True

        &#34;&#34;&#34;
        class_name = self.__class__.__name__

        return f&#34;&lt;{class_name} at {str(self.root)}&gt;&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="temptree.TemporaryTree.root"><code class="name">var <span class="ident">root</span></code></dt>
<dd>
<section class="desc"><p>The root of the tree as a <code>pathlib.Path</code> object.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def root(self):
    &#34;&#34;&#34;The root of the tree as a `pathlib.Path` object.&#34;&#34;&#34;
    return Path(self._root.name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="temptree.TemporaryTree.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Cleans up the tree.</p>
<p>The root temporary directory is cleaned up:</p>
<pre><code>&gt;&gt;&gt; tree = TemporaryTree({"foo.py": None})
&gt;&gt;&gt; tree.root.exists()
True
&gt;&gt;&gt; tree.cleanup()
&gt;&gt;&gt; tree.root.exists()
False
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cleanup(self):
    &#34;&#34;&#34;Cleans up the tree.

    The root temporary directory is cleaned up:

        &gt;&gt;&gt; tree = TemporaryTree({&#34;foo.py&#34;: None})
        &gt;&gt;&gt; tree.root.exists()
        True
        &gt;&gt;&gt; tree.cleanup()
        &gt;&gt;&gt; tree.root.exists()
        False

    &#34;&#34;&#34;
    self._root.cleanup()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#development">Development</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#changelog">Changelog</a></li>
<li><a href="#license">License</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="temptree.FilenameError" href="#temptree.FilenameError">FilenameError</a></code></h4>
</li>
<li>
<h4><code><a title="temptree.TemporaryTree" href="#temptree.TemporaryTree">TemporaryTree</a></code></h4>
<ul class="">
<li><code><a title="temptree.TemporaryTree.cleanup" href="#temptree.TemporaryTree.cleanup">cleanup</a></code></li>
<li><code><a title="temptree.TemporaryTree.root" href="#temptree.TemporaryTree.root">root</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>